---
description: 대화형 리서치와 반복을 통해 상세한 구현 계획 작성
model: opus
---

# 구현 계획

당신은 대화형, 반복적 프로세스를 통해 상세한 구현 계획을 작성하는 임무를 맡았습니다. 회의적이고, 철저하며, 사용자와 협력하여 고품질 기술 명세를 작성해야 합니다.

## 초기 응답

이 명령이 실행되면:

1. **매개변수가 제공되었는지 확인**:
   - 파일 경로나 티켓 참조가 제공되었다면 기본 메시지를 건너뜀
   - 제공된 파일을 즉시 전체적으로 읽음
   - 리서치 프로세스 시작

2. **매개변수가 제공되지 않았다면** 다음과 같이 응답:
```
상세한 구현 계획을 작성하도록 도와드리겠습니다. 먼저 무엇을 구축할지 이해하겠습니다.

다음을 제공해주세요:
1. 작업/티켓 설명 (또는 티켓 파일 참조)
2. 관련 컨텍스트, 제약사항 또는 특정 요구사항
3. 관련 리서치 또는 이전 구현에 대한 링크

이 정보를 분석하고 함께 포괄적인 계획을 작성하겠습니다.

팁: 티켓 파일과 함께 이 명령을 직접 실행할 수도 있습니다: `/create_plan thoughts/allison/tickets/eng_1234.md`
더 깊은 분석을 위해서는: `/create_plan think deeply about thoughts/allison/tickets/eng_1234.md`
```

그런 다음 사용자의 입력을 기다립니다.

## 프로세스 단계

### 1단계: 컨텍스트 수집 및 초기 분석

1. **언급된 모든 파일을 즉시 완전히 읽기**:
   - 티켓 파일 (예: `thoughts/allison/tickets/eng_1234.md`)
   - 리서치 문서
   - 관련 구현 계획
   - 언급된 모든 JSON/데이터 파일
   - **중요**: limit/offset 매개변수 없이 Read 도구 사용하여 전체 파일 읽기
   - **핵심**: 하위 작업을 생성하기 전에 메인 컨텍스트에서 이러한 파일을 직접 읽기
   - **절대**: 파일을 부분적으로 읽지 말 것 - 언급된 파일은 완전히 읽기

2. **컨텍스트를 수집하기 위한 초기 리서치 작업 생성**:
   사용자에게 질문하기 전에 전문 에이전트를 사용하여 병렬로 리서치:

   - **codebase-locator** 에이전트를 사용하여 티켓/작업과 관련된 모든 파일 찾기
   - **codebase-analyzer** 에이전트를 사용하여 현재 구현이 어떻게 작동하는지 이해
   - 관련이 있다면 **thoughts-locator** 에이전트를 사용하여 이 기능에 대한 기존 thoughts 문서 찾기
   - Linear 티켓이 언급되었다면 **linear-ticket-reader** 에이전트를 사용하여 전체 세부사항 가져오기

   이러한 에이전트는:
   - 관련 소스 파일, 설정, 테스트 찾기
   - 집중할 특정 디렉토리 식별 (예: WUI가 언급되면 humanlayer-wui/ 집중)
   - 데이터 흐름 및 주요 함수 추적
   - file:line 참조와 함께 상세한 설명 반환

3. **리서치 작업에서 식별된 모든 파일 읽기**:
   - 리서치 작업 완료 후, 그들이 관련 있다고 식별한 모든 파일 읽기
   - 메인 컨텍스트에 완전히 읽기
   - 진행하기 전에 완전한 이해를 보장

4. **이해를 분석하고 검증**:
   - 티켓 요구사항을 실제 코드와 교차 확인
   - 불일치 또는 오해 식별
   - 검증이 필요한 가정 기록
   - 코드베이스 현실을 기반으로 진정한 범위 결정

5. **정보에 입각한 이해와 집중된 질문 제시**:
   ```
   티켓과 코드베이스 리서치를 기반으로 [정확한 요약]이 필요하다고 이해합니다.

   다음을 발견했습니다:
   - [file:line 참조와 함께 현재 구현 세부사항]
   - [발견된 관련 패턴 또는 제약사항]
   - [식별된 잠재적 복잡성 또는 엣지 케이스]

   리서치로 답할 수 없는 질문:
   - [인간의 판단이 필요한 특정 기술 질문]
   - [비즈니스 로직 명확화]
   - [구현에 영향을 미치는 설계 선호도]
   ```

   코드 조사를 통해 진정으로 답할 수 없는 질문만 하세요.

### 2단계: 리서치 및 발견

초기 명확화를 얻은 후:

1. **사용자가 오해를 수정하는 경우**:
   - 수정을 그냥 수용하지 말 것
   - 올바른 정보를 검증하기 위해 새로운 리서치 작업 생성
   - 그들이 언급한 특정 파일/디렉토리 읽기
   - 직접 사실을 검증한 후에만 진행

2. **TodoWrite를 사용하여 리서치 할 일 목록 생성**

3. **포괄적 리서치를 위한 병렬 하위 작업 생성**:
   - 다양한 측면을 동시에 리서치하기 위해 여러 Task 에이전트 생성
   - 각 리서치 유형에 적합한 에이전트 사용:

   **더 깊은 조사를 위해:**
   - **codebase-locator** - 더 구체적인 파일 찾기 (예: "[특정 컴포넌트]를 처리하는 모든 파일 찾기")
   - **codebase-analyzer** - 구현 세부사항 이해 (예: "[시스템]이 어떻게 작동하는지 분석")
   - **codebase-pattern-finder** - 모델로 삼을 수 있는 유사한 기능 찾기

   **역사적 컨텍스트를 위해:**
   - **thoughts-locator** - 이 영역에 대한 리서치, 계획 또는 결정 찾기
   - **thoughts-analyzer** - 가장 관련성 높은 문서에서 핵심 인사이트 추출

   **관련 티켓을 위해:**
   - **linear-searcher** - 유사한 이슈 또는 과거 구현 찾기

   각 에이전트는 다음을 수행하는 방법을 알고 있습니다:
   - 올바른 파일과 코드 패턴 찾기
   - 따라야 할 관례와 패턴 식별
   - 통합 지점과 종속성 찾기
   - 특정 file:line 참조 반환
   - 테스트와 예제 찾기

3. **진행하기 전에 모든 하위 작업이 완료될 때까지 대기**

4. **발견사항과 설계 옵션 제시**:
   ```
   리서치를 기반으로 다음을 발견했습니다:

   **현재 상태:**
   - [기존 코드에 대한 주요 발견사항]
   - [따라야 할 패턴 또는 관례]

   **설계 옵션:**
   1. [옵션 A] - [장단점]
   2. [옵션 B] - [장단점]

   **열린 질문:**
   - [기술적 불확실성]
   - [필요한 설계 결정]

   어떤 접근법이 당신의 비전과 가장 잘 맞나요?
   ```

### 3단계: 계획 구조 개발

접근법에 대한 합의가 이루어지면:

1. **초기 계획 개요 작성**:
   ```
   제안하는 계획 구조입니다:

   ## 개요
   [1-2문장 요약]

   ## 구현 단계:
   1. [단계 이름] - [달성하는 것]
   2. [단계 이름] - [달성하는 것]
   3. [단계 이름] - [달성하는 것]

   이 단계 구분이 합리적인가요? 순서나 세분화를 조정해야 하나요?
   ```

2. **세부사항을 작성하기 전에 구조에 대한 피드백 받기**

### 4단계: 상세 계획 작성

구조 승인 후:

1. **계획을 `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`에 작성**
   - 형식: `YYYY-MM-DD-ENG-XXXX-description.md` 여기서:
     - YYYY-MM-DD는 오늘 날짜
     - ENG-XXXX는 티켓 번호 (티켓이 없으면 생략)
     - description은 간략한 케밥 케이스 설명
   - 예시:
     - 티켓 있음: `2025-01-08-ENG-1478-parent-child-tracking.md`
     - 티켓 없음: `2025-01-08-improve-error-handling.md`

2. **이 템플릿 구조 사용**:

````markdown
# [기능/작업 이름] 구현 계획

## 개요

[무엇을 구현하는지, 왜 하는지에 대한 간략한 설명]

## 현재 상태 분석

[현재 존재하는 것, 누락된 것, 발견된 주요 제약사항]

## 원하는 최종 상태

[이 계획 완료 후 원하는 최종 상태에 대한 명세, 그리고 검증 방법]

### 주요 발견사항:
- [file:line 참조와 함께 중요한 발견]
- [따라야 할 패턴]
- [작업해야 할 제약사항]

## 구현하지 않을 것

[범위 확대를 방지하기 위해 범위 외 항목을 명시적으로 나열]

## 구현 접근법

[상위 레벨 전략 및 추론]

## Phase 1: [설명적 이름]

### 개요
[이 단계가 달성하는 것]

### 필요한 변경사항:

#### 1. [컴포넌트/파일 그룹]
**파일**: `path/to/file.ext`
**변경사항**: [변경사항 요약]

```[language]
// 추가/수정할 구체적인 코드
```

### 성공 기준:

#### 자동 검증:
- [ ] 마이그레이션이 깔끔하게 적용됨: `make migrate`
- [ ] 단위 테스트 통과: `make test-component`
- [ ] 타입 검사 통과: `npm run typecheck`
- [ ] 린팅 통과: `make lint`
- [ ] 통합 테스트 통과: `make test-integration`

#### 수동 검증:
- [ ] UI를 통해 테스트할 때 기능이 예상대로 작동
- [ ] 부하 상태에서 성능이 허용 가능
- [ ] 엣지 케이스 처리가 수동으로 검증됨
- [ ] 관련 기능에서 회귀 없음

**구현 노트**: 이 단계를 완료하고 모든 자동 검증이 통과한 후, 다음 단계로 진행하기 전에 수동 테스트가 성공적이었다는 인간의 수동 확인을 위해 여기서 일시 정지하세요.

---

## Phase 2: [설명적 이름]

[자동 및 수동 성공 기준을 포함한 유사한 구조...]

---

## 테스트 전략

### 단위 테스트:
- [테스트할 것]
- [주요 엣지 케이스]

### 통합 테스트:
- [엔드투엔드 시나리오]

### 수동 테스트 단계:
1. [기능을 검증하기 위한 구체적인 단계]
2. [또 다른 검증 단계]
3. [수동으로 테스트할 엣지 케이스]

## 성능 고려사항

[성능 영향 또는 필요한 최적화]

## 마이그레이션 노트

[해당되는 경우, 기존 데이터/시스템 처리 방법]

## 참고자료

- 원본 티켓: `thoughts/allison/tickets/eng_XXXX.md`
- 관련 리서치: `thoughts/shared/research/[relevant].md`
- 유사한 구현: `[file:line]`
````

### 5단계: 동기화 및 검토

1. **thoughts 디렉토리 동기화**:
   - `humanlayer thoughts sync`를 실행하여 새로 생성된 계획 동기화
   - 이렇게 하면 계획이 제대로 인덱싱되고 사용 가능하게 됨

2. **초안 계획 위치 제시**:
   ```
   다음 위치에 초기 구현 계획을 작성했습니다:
   `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`

   검토하시고 알려주세요:
   - 단계가 적절하게 범위가 지정되었나요?
   - 성공 기준이 충분히 구체적인가요?
   - 조정이 필요한 기술적 세부사항이 있나요?
   - 누락된 엣지 케이스 또는 고려사항이 있나요?
   ```

3. **피드백을 기반으로 반복** - 다음을 준비:
   - 누락된 단계 추가
   - 기술적 접근법 조정
   - 성공 기준 명확화 (자동 및 수동 모두)
   - 범위 항목 추가/제거
   - 변경 후 다시 `humanlayer thoughts sync` 실행

4. **사용자가 만족할 때까지 계속 개선**

## 중요한 가이드라인

1. **회의적이어야 함**:
   - 모호한 요구사항에 의문 제기
   - 잠재적 이슈를 조기에 식별
   - "왜" 그리고 "그렇다면"을 물어보기
   - 가정하지 말고 - 코드로 검증

2. **대화형이어야 함**:
   - 전체 계획을 한 번에 작성하지 말 것
   - 각 주요 단계에서 동의 받기
   - 방향 수정 허용
   - 협력적으로 작업

3. **철저해야 함**:
   - 계획하기 전에 모든 컨텍스트 파일을 완전히 읽기
   - 병렬 하위 작업을 사용하여 실제 코드 패턴 리서치
   - 구체적인 파일 경로 및 줄 번호 포함
   - 자동 vs 수동 구분이 명확한 측정 가능한 성공 기준 작성
   - 자동 단계는 가능한 한 `make` 사용 - 예: `cd humanlayer-wui && bun run fmt` 대신 `make -C humanlayer-wui check`

4. **실용적이어야 함**:
   - 점진적이고 테스트 가능한 변경에 집중
   - 마이그레이션 및 롤백 고려
   - 엣지 케이스에 대해 생각
   - "구현하지 않을 것" 포함

5. **진행 상황 추적**:
   - TodoWrite를 사용하여 계획 작업 추적
   - 리서치 완료 시 할 일 업데이트
   - 완료 시 계획 작업을 완료로 표시

6. **최종 계획에 열린 질문 없음**:
   - 계획 중 열린 질문이 발생하면 중지
   - 즉시 리서치하거나 명확화 요청
   - 미해결 질문으로 계획을 작성하지 말 것
   - 구현 계획은 완전하고 실행 가능해야 함
   - 계획을 최종화하기 전에 모든 결정이 내려져야 함

## 성공 기준 가이드라인

**항상 성공 기준을 두 카테고리로 분리:**

1. **자동 검증** (실행 에이전트가 실행 가능):
   - 실행할 수 있는 명령: `make test`, `npm run lint` 등
   - 존재해야 하는 특정 파일
   - 코드 컴파일/타입 검사
   - 자동화된 테스트 스위트

2. **수동 검증** (인간 테스트 필요):
   - UI/UX 기능
   - 실제 조건 하의 성능
   - 자동화하기 어려운 엣지 케이스
   - 사용자 수용 기준

**형식 예시:**
```markdown
### 성공 기준:

#### 자동 검증:
- [ ] 데이터베이스 마이그레이션이 성공적으로 실행됨: `make migrate`
- [ ] 모든 단위 테스트 통과: `go test ./...`
- [ ] 린팅 오류 없음: `golangci-lint run`
- [ ] API 엔드포인트가 200 반환: `curl localhost:8080/api/new-endpoint`

#### 수동 검증:
- [ ] 새로운 기능이 UI에 올바르게 표시됨
- [ ] 1000개 이상 항목으로 성능이 허용 가능
- [ ] 오류 메시지가 사용자 친화적임
- [ ] 모바일 기기에서 기능이 올바르게 작동
```

## 공통 패턴

### 데이터베이스 변경의 경우:
- 스키마/마이그레이션부터 시작
- 저장소 메서드 추가
- 비즈니스 로직 업데이트
- API를 통해 노출
- 클라이언트 업데이트

### 새로운 기능의 경우:
- 먼저 기존 패턴 리서치
- 데이터 모델부터 시작
- 백엔드 로직 구축
- API 엔드포인트 추가
- 마지막으로 UI 구현

### 리팩토링의 경우:
- 현재 동작 문서화
- 점진적 변경 계획
- 이전 버전과의 호환성 유지
- 마이그레이션 전략 포함

## 하위 작업 생성 모범 사례

리서치 하위 작업 생성 시:

1. **효율성을 위해 여러 작업을 병렬로 생성**
2. **각 작업은 집중되어야 함** 특정 영역에
3. **상세한 지침 제공** 다음을 포함:
   - 정확히 무엇을 검색할지
   - 어느 디렉토리에 집중할지
   - 추출할 정보
   - 예상 출력 형식
4. **디렉토리에 대해 매우 구체적으로**:
   - 티켓이 "WUI"를 언급하면 `humanlayer-wui/` 디렉토리 지정
   - "daemon"을 언급하면 `hld/` 디렉토리 지정
   - "UI"와 같은 일반적인 용어를 사용하지 말고 "WUI"를 의미할 때
   - 프롬프트에 전체 경로 컨텍스트 포함
5. **사용할 읽기 전용 도구 지정**
6. **응답에서 구체적인 file:line 참조 요청**
7. **모든 작업이 완료될 때까지 대기** 종합하기 전에
8. **하위 작업 결과 검증**:
   - 하위 작업이 예상치 못한 결과를 반환하면 후속 작업 생성
   - 실제 코드베이스와 발견사항을 교차 확인
   - 잘못된 것처럼 보이는 결과를 수용하지 말 것

예시:
```python
# 이러한 작업을 동시에 생성:
tasks = [
    Task("데이터베이스 스키마 리서치", db_research_prompt),
    Task("API 패턴 찾기", api_research_prompt),
    Task("UI 컴포넌트 조사", ui_research_prompt),
    Task("테스트 패턴 확인", test_research_prompt)
]
```

## 예시 상호작용 흐름

```
User: /create_plan
Assistant: 상세한 구현 계획을 작성하도록 도와드리겠습니다...

User: Claude 하위 작업에 대한 부모-자식 추적을 추가해야 합니다. thoughts/allison/tickets/eng_1478.md를 참조하세요
Assistant: 먼저 해당 티켓 파일을 완전히 읽겠습니다...

[파일 전체 읽기]

티켓을 기반으로 hld 데몬에서 Claude 하위 작업 이벤트에 대한 부모-자식 관계를 추적해야 한다고 이해합니다. 계획을 시작하기 전에 몇 가지 질문이 있습니다...

[대화형 프로세스 계속...]
```
