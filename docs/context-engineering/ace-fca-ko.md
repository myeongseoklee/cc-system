# 복잡한 코드베이스에서 AI를 작동시키기

AI 코딩 도구가 실제 프로덕션 코드베이스에서 어려움을 겪는다는 것은 꽤 널리 받아들여지는 것 같습니다. [개발자 생산성에 대한 AI의 영향에 관한 Stanford 연구](https://www.youtube.com/watch?v=tbDDYKRFjhk)에서는 다음을 발견했습니다:

1. AI 도구로 생산된 "추가 코드"의 상당수는 지난주에 생산된 조잡한 코드를 재작업하는 것으로 끝납니다.
2. 코딩 에이전트는 새 프로젝트나 작은 변경에는 훌륭하지만, 대규모 기존 코드베이스에서는 개발자를 _오히려 덜_ 생산적으로 만들 수 있습니다.

일반적인 반응은 비관적인 "이것은 절대 작동하지 않을 것"과 좀 더 신중한 "언젠가 더 똑똑한 모델이 나오면 가능할지도" 사이 어딘가입니다.

몇 달간의 실험 끝에, 저는 **핵심 컨텍스트 엔지니어링 원칙을 수용한다면 오늘날의 모델로도 정말 멀리 갈 수 있다**는 것을 발견했습니다.

이것은 또 다른 "생산성 10배 향상" 홍보가 아닙니다. 저는 [AI 과대광고 기계와 접촉할 때 꽤 신중한 편입니다](https://hlyr.dev/12fa). 하지만 우리는 가능한 것에 대해 상당한 낙관론을 갖게 하는 워크플로우를 우연히 발견했습니다. 우리는 claude code로 300k LOC Rust 코드베이스를 처리하고, 일주일치 작업을 하루 만에 완료하며, 전문가 검토를 통과하는 코드 품질을 유지하도록 만들었습니다. 우리는 "빈번한 의도적 압축(frequent intentional compaction)"이라고 부르는 기술 계열을 사용합니다 - 개발 프로세스 전반에 걸쳐 AI에 컨텍스트를 제공하는 방식을 의도적으로 구조화하는 것입니다.

저는 이제 코딩을 위한 AI가 단순히 장난감과 프로토타입을 위한 것이 아니라, 깊이 있는 기술적 엔지니어링 기술이라고 완전히 확신합니다.

**비디오 버전**: 비디오를 선호하신다면, 이 게시물은 [8월 20일 Y Combinator에서 한 강연](https://hlyr.dev/ace)을 기반으로 합니다.

### AI Engineer의 맥락 배경

AI Engineer 2025의 두 강연이 이 문제에 대한 제 생각을 근본적으로 형성했습니다.

첫 번째는 [Sean Grove의 "Specs are the new code" 강연](https://www.youtube.com/watch?v=8rABwKRsec4)이고, 두 번째는 [개발자 생산성에 대한 AI의 영향에 관한 Stanford 연구](https://www.youtube.com/watch?v=tbDDYKRFjhk)입니다.

Sean은 우리 모두가 _vibe 코딩을 잘못하고 있다_고 주장했습니다. AI 에이전트와 두 시간 동안 채팅하고, 원하는 것을 지정한 다음, 최종 코드만 커밋하고 모든 프롬프트를 버리는 아이디어는... Java 개발자가 JAR을 컴파일하고 소스 코드는 버리면서 컴파일된 바이너리만 체크인하는 것과 같습니다.

Sean은 AI 미래에서는 스펙이 진짜 코드가 될 것이라고 제안합니다. 2년 후면, 오늘날 어셈블리를 읽기 위해 헥스 에디터를 열 때와 비슷한 빈도로 IDE에서 파이썬 파일을 열게 될 것이라고 합니다(대부분의 우리에게는 절대 없는 일입니다).

[Yegor의 개발자 생산성 강연](https://www.youtube.com/watch?v=tbDDYKRFjhk)은 직교하는 문제를 다뤘습니다. 그들은 100k 개발자의 커밋을 분석했고, 무엇보다도 다음을 발견했습니다:

1. AI 도구가 종종 많은 재작업으로 이어져, 인지된 생산성 향상을 감소시킵니다

<img width="800" alt="image" src="https://github.com/user-attachments/assets/f7cec497-3ee2-47d1-8f91-a18210625e19" />

2. AI 도구는 그린필드 프로젝트에는 잘 작동하지만, 브라운필드 코드베이스와 복잡한 작업에서는 종종 역효과를 냅니다

<img width="700" alt="Screenshot 2025-08-29 at 10 55 32 AM" src="https://github.com/user-attachments/assets/06f03232-f9d9-4a92-a182-37056bf877a4" />

이것은 제가 창업자들과 이야기하면서 들은 것과 일치했습니다:

- "너무 많은 조잡한 코드."
- "기술 부채 공장."
- "큰 저장소에서는 작동하지 않는다."
- "복잡한 시스템에서는 작동하지 않는다."

어려운 작업을 위한 AI 코딩에 대한 일반적인 분위기는

> 언젠가, 모델이 더 똑똑해지면...

심지어 [Amjad](https://x.com/amasad)도 [9개월 전 lenny's 팟캐스트](https://www.lennysnewsletter.com/p/behind-the-product-replit-amjad-masad)에서 PM들이 Replit agent를 사용해 새로운 것을 프로토타이핑하고 나서 엔지니어들에게 넘겨 프로덕션을 위해 구현하도록 한다고 이야기했습니다.
(면책: 최근에 그를 따라잡지 못했습니다 (좋아요, 전혀), 이 입장은 바뀌었을 수 있습니다)

"언젠가 모델이 똑똑해지면"이라는 말을 들을 때마다 저는 일반적으로 **그것이 바로 컨텍스트 엔지니어링의 전부입니다**라고 외칩니다: _오늘날의_ 모델에서 최대한을 얻어내는 것.

### 오늘날 실제로 가능한 것

이것이 단순한 이론이 아님을 증명하기 위해, 구체적인 예를 설명하겠습니다. 몇 주 전, 저는 LLM과 작동하는 프로그래밍 언어인 [BAML](https://github.com/BoundaryML/baml), 300k LOC Rust 코드베이스에서 우리의 기술을 테스트하기로 결정했습니다. 저는 기껏해야 아마추어 Rust 개발자이고 BAML 코드베이스를 전혀 건드려본 적이 없었습니다.

한 시간 정도 내에, 저는 [버그를 수정하는 PR](https://github.com/BoundaryML/baml/pull/2259#issuecomment-3155883849)을 작성했고, 다음 날 아침 유지 관리자가 승인했습니다. 몇 주 후, [@hellovai](https://x.com/hellovai)와 저는 BAML에 35k LOC를 배포하며 [취소 지원](https://github.com/BoundaryML/baml/pull/2357)과 [WASM 컴파일](https://github.com/BoundaryML/baml/pull/2330)을 추가했습니다 - 팀이 각각 시니어 엔지니어가 3-5일이 걸릴 것으로 추정한 기능들입니다. 우리는 약 7시간 만에 두 PR 초안을 모두 준비했습니다.

다시 말하지만, 이것은 모두 우리가 [빈번한 의도적 압축](#훨씬-더-잘-작동하는-것-빈번한-의도적-압축)이라고 부르는 워크플로우를 중심으로 구축되었습니다 - 본질적으로 컨텍스트 관리를 중심으로 전체 개발 프로세스를 설계하고, 활용도를 40-60% 범위로 유지하며, 정확히 적절한 지점에서 높은 레버리지의 인간 검토를 구축하는 것입니다. 우리는 "연구, 계획, 구현" 워크플로우를 사용하지만, 여기의 핵심 역량/학습은 특정 워크플로우나 프롬프트 세트보다 훨씬 더 일반적입니다.

### 여기에 도달하기까지의 우리의 이상한 여정

저는 제가 만난 가장 생산적인 AI 코더 중 한 명과 일하고 있었습니다.
며칠마다 그들은 **2000줄 Go PR**을 제출했습니다.
그리고 이것은 nextjs 앱이나 CRUD API가 아니었습니다. 이것은 JSON RPC over unix 소켓을 수행하고 포크된 unix 프로세스에서 스트리밍 stdio를 관리하는 복잡한 [경쟁 조건이 발생하기 쉬운 시스템 코드](https://github.com/humanlayer/humanlayer/blob/main/hld/daemon/daemon_subscription_integration_test.go#L45)였습니다(대부분 claude code sdk 프로세스, 나중에 더 자세히 🙂).

며칠마다 2,000줄의 복잡한 Go 코드를 주의 깊게 읽는다는 아이디어는 단순히 지속 가능하지 않았습니다. 저는 Mitchell Hashimoto가 ghostty에 [AI 기여는 공개되어야 한다](https://github.com/ghostty-org/ghostty/pull/8289)는 규칙을 추가했을 때와 비슷한 느낌을 받기 시작했습니다.

우리의 접근 방식은 sean의 **스펙 주도 개발**과 같은 것을 채택하는 것이었습니다.

처음에는 불편했습니다.
저는 PR 코드의 모든 줄을 읽는 것을 놓아주는 법을 배워야 했습니다.
저는 여전히 테스트를 꽤 주의 깊게 읽지만, 스펙이 무엇이 구축되고 있고 왜 그런지에 대한 우리의 진실의 원천이 되었습니다.

변화는 약 8주가 걸렸습니다.
관련된 모든 사람, 특히 저에게 매우 불편했습니다.
하지만 이제 우리는 날아가고 있습니다. 몇 주 전, 저는 하루에 6개의 PR을 배포했습니다.
지난 3개월 동안 손으로 마크다운이 아닌 파일을 편집한 횟수를 한 손으로 셀 수 있습니다.

## 코딩 에이전트를 위한 고급 컨텍스트 엔지니어링

우리에게 필요했던 것은:

- 브라운필드 코드베이스에서 잘 작동하는 AI
- 복잡한 문제를 해결하는 AI
- 조잡한 코드 없음
- 팀 전체에 걸쳐 정신적 정렬 유지

(그리고 네, 가능한 한 많은 토큰을 사용하려고 노력합시다.)

저는 다음에 대해 논의하겠습니다:

1. 코딩 에이전트에 컨텍스트 엔지니어링을 적용하면서 배운 것
2. 이러한 에이전트를 사용하는 것이 깊이 있는 기술적 기술인 차원
3. 왜 저는 이러한 접근 방식이 일반화 가능하다고 믿지 않는지
4. (3)에 대해 반복적으로 틀렸던 횟수

### 하지만 먼저: 에이전트 컨텍스트를 관리하는 순진한 방법

우리 대부분은 코딩 에이전트를 챗봇처럼 사용하는 것으로 시작합니다. 당신은 그것과 앞뒤로 이야기하며 (또는 [술에 취해 소리치며](https://ghuntley.com/six-month-recap/#:~:text=Last%20week%2C%20over%20Zoom%20margaritas%2C%20a%20friend%20and%20I%20reminisced%20about%20COBOL.)), 컨텍스트가 바닥날 때까지, 포기할 때까지, 또는 에이전트가 사과하기 시작할 때까지 문제를 통해 분위기를 타고 갑니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/7361a203-9d95-42e2-ac16-1f38b04adb58" />

약간 더 똑똑한 방법은 궤도를 벗어났을 때 처음부터 다시 시작하는 것입니다. 세션을 버리고 새로운 세션을 시작하며, 아마도 프롬프트에 약간 더 많은 조향을 추가합니다.

> [원래 프롬프트], 하지만 XYZ 접근 방식을 사용해야 합니다. ABC 접근 방식은 작동하지 않을 것이기 때문입니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/1bbbc8ad-60da-4f8b-98c3-e6603b04a0ce" />

### 약간 더 똑똑함: 의도적 압축

당신은 아마도 제가 "의도적 압축"이라고 부르게 된 것을 해본 적이 있을 것입니다. 궤도를 벗어났든 아니든, 컨텍스트가 채워지기 시작하면, 아마도 작업을 일시 중지하고 새로운 컨텍스트 창으로 처음부터 시작하고 싶을 것입니다. 이를 위해 다음과 같은 프롬프트를 사용할 수 있습니다:

> "지금까지 한 모든 것을 progress.md에 작성하세요. 최종 목표, 우리가 취하고 있는 접근 방식, 지금까지 수행한 단계, 그리고 우리가 작업하고 있는 현재 실패를 메모하세요"

<img width="800" alt="image" src="https://github.com/user-attachments/assets/64b940e5-89b1-4f6c-a79c-ec2810d9af77" />

[의도적 압축을 위해 커밋 메시지를 사용](https://x.com/dexhorthy/status/1961490837017088051)할 수도 있습니다.

### 정확히 무엇을 압축하고 있나요?

무엇이 컨텍스트를 소모하나요?

- 파일 검색
- 코드 흐름 이해
- 편집 적용
- 테스트/빌드 로그
- 도구의 거대한 JSON blob

이 모든 것들이 컨텍스트 창을 넘칠 수 있습니다. **압축**은 단순히 이것들을 구조화된 아티팩트로 증류하는 것입니다.

의도적 압축의 좋은 출력은 다음과 같은 것을 포함할 수 있습니다:

<img width="700" alt="Screenshot 2025-08-29 at 11 10 36 AM" src="https://github.com/user-attachments/assets/a7d5946d-4e81-46e8-b314-d02dae1f00ee" />

### 왜 컨텍스트에 집착하나요?

[12-factor agents](https://hlyr.dev/12fa)에서 깊이 다뤘듯이, LLM은 상태 비저장 함수입니다. (모델 자체를 훈련/튜닝하지 않고) 출력 품질에 영향을 미치는 유일한 것은 입력의 품질입니다.

이것은 일반 에이전트 설계와 마찬가지로 코딩 에이전트를 [휘두르는](https://www.youtube.com/watch?v=F_RyElT_gJk) 것에도 마찬가지로 적용됩니다. 다만 문제 공간이 더 작고, 에이전트를 구축하는 것이 아니라 에이전트를 사용하는 것에 대해 이야기하고 있습니다.

어느 시점에서든, claude code와 같은 에이전트의 턴은 상태 비저장 함수 호출입니다. 컨텍스트 창이 들어가고, 다음 단계가 나옵니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/c1e920e8-5dc5-4dd2-b76d-853b85a92e6a" />

즉, 컨텍스트 창의 내용이 출력 품질에 영향을 미칠 수 있는 유일한 레버입니다. 그래서 네, 그것에 집착할 가치가 있습니다.

컨텍스트 창을 다음을 위해 최적화해야 합니다:

1. 정확성
2. 완전성
3. 크기
4. 궤적

다르게 말하면, 컨텍스트 창에 일어날 수 있는 최악의 일들은 순서대로:

1. 잘못된 정보
2. 누락된 정보
3. 너무 많은 노이즈

방정식을 좋아한다면, 참조할 수 있는 멍청한 방정식이 여기 있습니다:

<img width="700" alt="Screenshot 2025-08-29 at 11 11 30 AM" src="https://github.com/user-attachments/assets/a6ea98a6-665b-48af-983b-a1cb2c45e44c" />

[Geoff Huntley](https://x.com/GeoffreyHuntley)가 말하듯이,

> 게임의 이름은 작업할 수 있는 컨텍스트 창이 약 **170k**라는 것입니다.
> 따라서 가능한 한 적게 사용하는 것이 필수적입니다.
> 컨텍스트 창을 많이 사용할수록 얻는 결과가 더 나빠집니다.

Geoff의 이 엔지니어링 제약에 대한 솔루션은 그가 [Ralph Wiggum as a Software Engineer](https://ghuntley.com/ralph/)라고 부르는 기술입니다. 기본적으로 간단한 프롬프트로 에이전트를 무한 루프에서 실행하는 것입니다.

```
while :; do
  cat PROMPT.md | npx --yes @sourcegraph/amp
done
```

ralph나 PROMPT.md에 무엇이 있는지 더 알고 싶다면, Geoff의 게시물을 확인하거나 지난 주말 YC Agents 해커톤에서 [@simonfarshid](https://x.com/simonfarshid), [@lantos1618](https://x.com/lantos1618), [@AVGVSTVS96](https://x.com/AVGVSTVS96) 그리고 제가 구축한 프로젝트에 들어가볼 수 있습니다. 이 프로젝트는 (대부분) [BrowserUse를 TypeScript로 하룻밤 사이에 포팅](https://github.com/repomirrorhq/repomirror/blob/main/repomirror.md)할 수 있었습니다.

Geoff는 ralph를 컨텍스트 창 문제에 대한 "우스꽝스럽게 멍청한" 솔루션이라고 설명합니다. [저는 그것이 멍청하다고 완전히 확신하지 않습니다](https://ghuntley.com/content/images/size/w2400/2025/07/The-ralph-Process.png).

### 압축으로 돌아가기: 서브 에이전트 사용

서브 에이전트는 컨텍스트를 관리하는 또 다른 방법이며, 일반 서브 에이전트(즉, [커스텀](https://docs.anthropic.com/en/docs/claude-code/sub-agents)이 아닌)는 초기부터 claude code와 많은 코딩 CLI의 기능이었습니다.

서브 에이전트는 [역할을 의인화하는 것](https://x.com/dexhorthy/status/1950288431122436597)에 관한 것이 아닙니다. 서브 에이전트는 컨텍스트 제어에 관한 것입니다.

서브 에이전트의 가장 일반적이고 직관적인 사용 사례는 새로운 컨텍스트 창을 사용하여 찾기/검색/요약을 수행하도록 하여, 부모 에이전트가 `Glob` / `Grep` / `Read` 등의 호출로 컨텍스트 창을 흐리게 하지 않고 바로 작업에 착수할 수 있도록 하는 것입니다.

https://github.com/user-attachments/assets/cb4e7864-9556-4eaa-99ca-a105927f484d

<details><summary>(모바일에서 비디오가 재생되지 않나요? 정적 이미지 버전을 보려면 펼치세요)</summary>
  <img width="800" alt="image" src="https://github.com/user-attachments/assets/c72e7dba-1476-4ee9-9cb0-0f97d428b82a" />
</details>

이상적인 서브 에이전트 응답은 아마도 위의 이상적인 임시 압축과 비슷하게 보일 것입니다:

<img width="700" alt="Screenshot 2025-08-29 at 11 10 36 AM" src="https://github.com/user-attachments/assets/a7d5946d-4e81-46e8-b314-d02dae1f00ee" />

서브 에이전트가 이것을 반환하도록 하는 것은 간단하지 않습니다:

<img width="800" alt="image" src="https://github.com/user-attachments/assets/2bcd30f6-84fd-4911-ac15-63f75619e76d" />

### 훨씬 더 잘 작동하는 것: 빈번한 의도적 압축

제가 이야기하고 싶고 우리가 지난 몇 달간 채택한 기술은 제가 "빈번한 의도적 압축"이라고 부르는 것에 속합니다.

본질적으로, 이것은 컨텍스트 관리를 중심으로 전체 워크플로우를 설계하고, 활용도를 40%-60% 범위로 유지하는 것을 의미합니다(문제의 복잡성에 따라 다릅니다).

우리가 하는 방식은 세 가지(정도) 단계로 나누는 것입니다.

제가 "정도"라고 말하는 이유는 때때로 연구를 건너뛰고 바로 계획으로 가거나, 구현할 준비가 되기 전에 압축된 연구를 여러 번 수행하기 때문입니다.

아래 구체적인 예에서 각 단계의 예제 출력을 공유하겠습니다. 주어진 기능이나 버그에 대해 우리는 다음을 수행하는 경향이 있습니다:

**연구**

코드베이스, 이슈와 관련된 파일, 정보가 어떻게 흐르는지, 그리고 아마도 문제의 잠재적 원인을 이해합니다.

여기 우리의 [연구 프롬프트](https://github.com/humanlayer/humanlayer/blob/main/.claude/commands/research_codebase.md)가 있습니다.
현재는 커스텀 서브 에이전트를 사용하지만, 다른 저장소에서는 claude code Task() 도구를 `general-agent`와 함께 사용하는 더 일반적인 버전을 사용합니다.
일반적인 것도 거의 잘 작동합니다.

**계획**

이슈를 수정하기 위해 취할 정확한 단계, 편집해야 할 파일과 방법을 개요로 작성하며, 각 단계의 테스트/검증 단계에 대해 매우 정확하게 작성합니다.

이것은 [계획에 사용하는 프롬프트](https://github.com/humanlayer/humanlayer/blob/main/.claude/commands/create_plan.md)입니다.

**구현**

계획을 단계별로 진행합니다. 복잡한 작업의 경우, 각 구현 단계가 검증된 후 현재 상태를 원래 계획 파일로 다시 압축하는 경우가 많습니다.

이것은 [우리가 사용하는 구현 프롬프트](https://github.com/humanlayer/humanlayer/blob/main/.claude/commands/implement_plan.md)입니다.

참고 - git worktree에 대해 많이 들어봤다면, 이것은 worktree에서 수행해야 하는 유일한 단계입니다. 우리는 다른 모든 것을 main에서 수행하는 경향이 있습니다.

**마크다운 파일을 관리/공유하는 방법**

간결함을 위해 이 부분은 건너뛰겠지만, [humanlayer/humanlayer](https://github.com/humanlayer/humanlayer)에서 claude 세션을 시작하고 "thoughts tool"이 어떻게 작동하는지 물어보세요.

### 실제로 적용하기

저는 [@vaibhav](https://www.linkedin.com/in/vaigup/)와 함께 [주간 라이브 코딩 세션](https://github.com/ai-that-works/ai-that-works)을 합니다. 우리는 고급 AI 엔지니어링 문제에 대한 솔루션을 화이트보드에 그리고 코딩합니다. 그것은 제 주의 하이라이트 중 하나입니다.

몇 주 전, 저는 [프로세스에 대해 더 많이 공유하기로 결정했습니다](https://hlyr.dev/he-gh). 우리의 내부 기술이 LLM과 작동하는 프로그래밍 언어인 BAML을 위한 300k LOC Rust 코드베이스의 수정을 원샷으로 처리할 수 있을지 궁금했습니다. 저는 @BoundaryML 저장소에서 [(분명히 작은) 버그](https://github.com/BoundaryML/baml/issues/1252)를 골라서 작업을 시작했습니다.

프로세스에 대해 더 알고 싶다면 [에피소드를 시청](https://hlyr.dev/he-yt)할 수 있지만, 개요는 다음과 같습니다:

**주목할 가치가 있는 것**: 저는 기껏해야 아마추어 Rust 개발자이고, BAML 코드베이스에서 작업한 적이 없습니다.

#### 연구

- 저는 연구를 작성하고, 읽었습니다. Claude는 버그가 유효하지 않고 코드베이스가 정확하다고 결정했습니다.
- 저는 그 연구를 버리고 더 많은 조향을 추가하여 새로운 연구를 시작했습니다.
- 여기 [제가 결국 사용한 최종 연구 문서](https://github.com/ai-that-works/ai-that-works/blob/main/2025-08-05-advanced-context-engineering-for-coding-agents/thoughts/shared/research/2025-08-05_05-15-59_baml_test_assertions.md)가 있습니다.

#### 계획

- 연구가 실행되는 동안, 저는 참을성이 없어서 연구 없이 계획을 시작했습니다. claude가 바로 구현 계획으로 갈 수 있는지 보기 위해서였습니다 - [여기서 볼 수 있습니다](https://github.com/ai-that-works/ai-that-works/blob/main/2025-08-05-advanced-context-engineering-for-coding-agents/thoughts/shared/plans/fix-assert-syntax-validation-no-research.md)
- 연구가 완료되었을 때, 저는 연구 결과를 사용한 또 다른 구현 계획을 시작했습니다 - [여기서 볼 수 있습니다](https://github.com/ai-that-works/ai-that-works/blob/main/2025-08-05-advanced-context-engineering-for-coding-agents/thoughts/shared/plans/baml-test-assertion-validation-with-research.md)

계획은 둘 다 꽤 짧지만 상당히 다릅니다. 그들은 다른 방식으로 이슈를 수정하고, 다른 테스트 접근 방식을 가지고 있습니다. 너무 많이 자세히 설명하지 않고, 둘 다 "작동했을 것"이지만 연구로 구축된 것이 _최고의_ 장소에서 문제를 수정했고 코드베이스 관례에 맞는 테스트를 처방했습니다.

#### 구현

- 이 모든 것은 팟캐스트 녹음 전날 밤에 일어났습니다. 저는 두 계획을 병렬로 실행하고 밤을 마무리하기 전에 둘 다 PR로 제출했습니다.

다음 날 오전 10시 PT에 쇼에 출연할 때쯤, [연구가 있는 계획의 PR은 이미 @aaron에 의해 승인되었습니다](https://github.com/BoundaryML/baml/pull/2259#issuecomment-3155883849). 그는 제가 팟캐스트를 위한 비트를 하고 있다는 것을 몰랐습니다 🙂. 우리는 [다른 것을 닫았습니다](https://github.com/BoundaryML/baml/pull/2258/files).

그래서 원래의 4가지 목표 중에서 우리는 달성했습니다:

- ✅ 브라운필드 코드베이스에서 작동 (300k LOC rust 프로젝트)
- 복잡한 문제 해결
- ✅ 조잡한 코드 없음 (pr 병합됨)
- 정신적 정렬 유지

### 복잡한 문제 해결

Vaibhav는 여전히 회의적이었고, 저는 더 복잡한 문제를 해결할 수 있는지 보고 싶었습니다.

그래서 몇 주 후, 우리 둘은 7시간(연구/계획에 3시간, 구현에 4시간)을 보내고 BAML에 취소 및 wasm 지원을 추가하기 위해 35k LOC를 배포했습니다.
[취소 PR은 지난주에 병합되었습니다](https://github.com/BoundaryML/baml/pull/2357). [WASM PR은 여전히 열려 있습니다](https://github.com/BoundaryML/baml/pull/2330)만, 브라우저의 JS 앱에서 wasm으로 컴파일된 rust 런타임을 호출하는 작동하는 데모가 있습니다.

취소 PR이 작업을 마무리하기 위해 약간 더 많은 사랑이 필요했지만, 우리는 단 하루 만에 놀라운 진전을 이뤘습니다. Vaibhav는 이러한 PR 각각이 BAML 팀의 시니어 엔지니어가 완료하는 데 3-5일의 작업이 될 것으로 추정했습니다.

✅ 그래서 우리는 복잡한 문제도 해결할 수 있습니다.

### 이것은 마법이 아닙니다

예제에서 제가 연구를 읽고 틀렸기 때문에 버렸던 부분을 기억하시나요? 또는 저와 Vaibhav가 7시간 동안 깊이 참여하고 있던 것을? 이것을 할 때 작업에 참여해야 합니다. 그렇지 않으면 작동하지 않습니다.

모든 문제를 해결할 하나의 마법 프롬프트를 항상 찾는 특정 유형의 사람들이 있습니다. 그것은 존재하지 않습니다.

연구/계획/구현 흐름을 통한 빈번한 의도적 압축은 성능을 **더 좋게** 만들지만, **어려운 문제에 충분히 좋게** 만드는 것은 파이프라인에 높은 레버리지의 인간 검토를 구축하는 것입니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/01c7818a-9a0d-4ede-a23b-fb0c2e80f843" />

### 얼굴에 계란

몇 주 전, [@blakesmith](https://www.linkedin.com/in/bhsmith/)와 저는 7시간 동안 앉아서 [parquet java에서 hadoop 종속성을 제거하려고 시도했습니다](https://github.com/dexhorthy/parquet-java/blob/remove-hadoop/thoughts/shared/plans/remove-hadoop-dependencies.md) - 무엇이 잘못되었고 왜 그런지에 대한 제 이론에 대한 깊은 탐구는 다른 게시물을 위해 남겨두겠습니다. 간단히 말하면 잘 되지 않았습니다. tl;dr은 연구 단계가 종속성 트리를 충분히 깊이 통과하지 않았고, 깊게 중첩된 hadoop 종속성을 도입하지 않고 클래스를 업스트림으로 이동할 수 있다고 가정했습니다.

7시간 만에 프롬프트로 해결할 수 없는 크고 어려운 문제들이 있으며, 우리는 여전히 친구 및 파트너와 함께 경계를 밀어붙이는 것에 대해 호기심 있고 흥분하며 해킹하고 있습니다. 여기서 다른 학습은 아마도 코드베이스의 전문가인 사람이 적어도 한 명 필요하다는 것이며, 이 경우에는 우리 둘 다 아니었습니다.

### 인간 레버리지에 대하여

이 모든 것에서 한 가지를 얻는다면, 이것이어야 합니다:

나쁜 코드 한 줄은... 나쁜 코드 한 줄입니다.
하지만 나쁜 **계획** 한 줄은 수백 줄의 나쁜 코드로 이어질 수 있습니다.
그리고 나쁜 **연구** 한 줄, 코드베이스가 어떻게 작동하는지 또는 특정 기능이 어디에 있는지에 대한 오해는 수천 줄의 나쁜 코드로 이어질 수 있습니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/dab49f61-caae-4c15-b481-ee9b8f64995f" />

그래서 파이프라인의 **가장 높은 레버리지** 부분에 **인간의 노력과 주의를 집중**하고 싶어합니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/cf981f70-5e61-4938-aa9a-7dcb88c9f8a4" />

연구와 계획을 검토할 때, 코드를 검토할 때보다 더 많은 레버리지를 얻습니다. (그런데, [humanlayer](https://hlyr.dev/code)에서 우리의 주요 초점 중 하나는 팀이 고품질 워크플로우 프롬프트를 구축하고 활용하며 AI 생성 코드 및 스펙을 위한 훌륭한 협업 워크플로우를 만드는 것을 돕는 것입니다).

### 코드 리뷰는 무엇을 위한 것인가요?

사람들은 코드 리뷰가 무엇을 위한 것인지에 대해 많은 다른 의견을 가지고 있습니다.

저는 [소프트웨어 팀을 위한 코드 리뷰 필수사항에서 Blake Smith의 프레이밍](https://blakesmith.me/2015/02/09/code-review-essentials-for-software-teams.html)을 선호합니다. 여기서 그는 코드 리뷰의 가장 중요한 부분은 정신적 정렬 - 코드가 어떻게 변경되고 있고 왜 그런지에 대해 팀 구성원들을 같은 페이지에 유지하는 것이라고 말합니다.

<img width="800" alt="image" src="https://github.com/user-attachments/assets/77f4001b-175f-4da6-a6d4-e00b80489476" />

그 2k 줄 golang PR을 기억하시나요? 저는 그것들이 올바르고 잘 설계되기를 원했지만, 팀 내부 불안과 좌절의 가장 큰 원인은 정신적 정렬의 부족이었습니다. **저는 우리의 제품이 무엇이고 어떻게 작동하는지 접촉을 잃기 시작했습니다.**

매우 생산적인 AI 코더와 일한 사람은 누구나 이런 경험을 했을 것으로 예상합니다.

이것은 실제로 우리에게 연구/계획/구현의 가장 중요한 부분입니다.
모든 사람이 훨씬 더 많은 코드를 배포하는 것의 보장된 부작용은 어느 시점에서든 코드베이스의 훨씬 더 큰 비율이 주어진 엔지니어에게 낯설 것이라는 것입니다.

저는 연구/계획/구현이 대부분의 팀에 적합한 접근 방식이라고 설득하려고 시도하지도 않을 것입니다 - 아마도 그렇지 않을 것입니다. 하지만 다음을 수행하는 엔지니어링 프로세스가 절대적으로 필요합니다:

1. 팀 구성원들을 같은 페이지에 유지
2. 팀 구성원들이 코드베이스의 낯선 부분에 대해 빠르게 배울 수 있도록 함

대부분의 팀에게 이것은 풀 리퀘스트와 내부 문서입니다. 우리에게는 이제 스펙, 계획, 그리고 연구입니다.

저는 매일 2000줄의 golang을 읽을 수 없습니다. 하지만 저는 잘 작성된 구현 계획의 200줄은 읽을 _수 있습니다_.

저는 무언가가 고장났을 때 40개 이상의 데몬 코드 파일을 한 시간 이상 탐험할 수 없습니다(좋아요, 할 수는 있지만 원하지 않습니다). 저는 어디를 봐야 하고 왜 그런지에 대한 스피드런을 제공하도록 연구 프롬프트를 조종할 _수 있습니다_.

### 요약

기본적으로 우리는 필요한 모든 것을 얻었습니다.

- ✅ 브라운필드 코드베이스에서 작동
- ✅ 복잡한 문제 해결
- ✅ 조잡한 코드 없음
- ✅ 정신적 정렬 유지

(오, 그리고 네, 우리 3명 팀은 한 달에 약 $12k의 opus를 평균적으로 사용합니다)

제가 단지 또 다른 [과대광고에 빠진 콧수염 난 영업 사원](https://www.youtube.com/watch?v=IS_y40zY-hc&lc=UgzFldRM6LU5unLuFn54AaABAg.AMKlTmJAT5ZAMKrOOAMw3I)이라고 생각하지 않도록, 이것이 모든 문제에 완벽하게 작동하지는 않는다는 점을 주목하겠습니다(우리는 parquet-java를 위해 다시 돌아올 것입니다).

8월에 전체 팀은 정말 까다로운 경쟁 조건에서 2주를 원을 그리며 돌았습니다. 그것은 golang의 MCP sHTTP keepalive 문제와 다른 많은 막다른 골목으로 이어지는 토끼굴로 나선했습니다.

하지만 그것은 이제 예외입니다. 일반적으로, 이것은 우리에게 잘 작동합니다. 우리 인턴은 첫날 2개의 PR을 배포했고, 8일째에 10개를 배포했습니다. 저는 다른 사람에게 작동할지 진정으로 회의적이었지만, 저와 Vaibhav는 7시간 만에 35k LOC의 작동하는 BAML 코드를 배포했습니다. (그리고 Vaibhav를 만나본 적이 없다면, 그는 코드 설계와 품질에 있어 제가 아는 가장 꼼꼼한 엔지니어 중 한 명입니다.)

### 앞으로 올 것

저는 코딩 에이전트가 상품화될 것이라고 합리적으로 확신합니다.

어려운 부분은 팀과 워크플로우 변환이 될 것입니다. AI가 우리 코드의 99%를 작성하는 세상에서 협업에 대한 모든 것이 바뀔 것입니다.

그리고 저는 이것을 해결하지 못하면, 해결한 누군가에게 따라잡힐 것이라고 꽤 강하게 믿습니다.

### 좋아요, 분명히 당신은 저에게 무언가를 팔 것이 있습니다

우리는 스펙 우선, 에이전트 워크플로우에 대해 꽤 낙관적이어서, 더 쉽게 만드는 도구를 구축하고 있습니다. 많은 것들 중에서, 저는 이러한 "빈번한 의도적 압축" 워크플로우를 대규모 팀에 걸쳐 협업적으로 확장하는 문제에 집착하고 있습니다.

오늘, 우리는 비공개 베타로 새로운 "포스트-IDE IDE"인 CodeLayer를 출시합니다 - "claude code를 위한 Superhuman"이라고 생각하세요. Superhuman 및/또는 vim 모드의 팬이고 "분위기 코딩"을 넘어서 에이전트로 진지하게 구축할 준비가 되었다면, 대기자 명단에 참여하시기 바랍니다.

**https://humanlayer.dev에서 가입하세요**.

## OSS 유지 관리자를 위해 - 함께 무언가를 배포합시다

복잡한 OSS 프로젝트의 유지 관리자이고 베이 에어리어에 있다면, 저의 열린 제안 - 저는 토요일에 SF에서 7시간 동안 직접 만나서 페어링하고 큰 것을 배포할 수 있는지 봅시다.

저는 이러한 기술이 부족한 한계에 대해 많은 것을 배웁니다(그리고, 운이 좋다면, 많은 가치를 추가하는 병합된 PR을 가리킬 수 있습니다). 당신은 제가 잘 작동한다고 발견한 유일한 방법인 직접 1x1 페어링으로 워크플로우를 배웁니다.

## 엔지니어링 리더를 위해

당신이나 당신이 아는 누군가가 AI로 팀의 생산성을 10배로 만들고 싶은 엔지니어링 리더라면, 우리는 AI 우선 코딩 세계로 전환하는 데 필요한 문화/프로세스/기술 변화를 추진하는 데 도움을 주기 위해 모든 규모의 팀과 함께 전진 배치하고 있습니다.

### 감사합니다

- 이 게시물의 초기 두서없는 버전을 들어준 모든 친구와 창업자들에게 감사합니다 - Adam, Josh, Andrew, 그리고 더 많은 분들
- 이 이상한 폭풍을 견뎌준 Sundeep에게 감사합니다
- 우리를 미래로 차며 비명을 지르며 끌고 간 Allison, Geoff, 그리고 Gerred에게 감사합니다

---

## 관련 문서

- [Create Plan 프롬프트](./create-plan-ko.md) - 구현 계획 작성 프로세스
- [Research Codebase 프롬프트](./research-codebase-ko.md) - 코드베이스 리서치 프로세스
- [객체지향 도메인 설계](../domain-design/README.md) - 설계 원칙과 패턴
